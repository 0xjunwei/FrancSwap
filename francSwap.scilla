scilla_version 0

(* Standard Libraries *)
import IntUtils BoolUtils


library FrancSwap
let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
fun (msg1 : Message) =>
fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let zero = Uint128 0
let ten = Uint128 10
let hundred = Uint128 100
let tenthousand = Uint128 10000
let tenInt = Uint32 10


let true = True
let false = False

type Error =
  | CodeInsufficientFunds
  | CodeInsufficientAllowance
  | CodeIsSender
  | CodeNotWhitelisted
  | CodeNotImplementation
  | CodeNotOwner
  | CodeContractPaused


let make_error =
  fun (result : Error) =>
  let result_code = 
  match result with
  | CodeInsufficientFunds       => Int32 1
  | CodeInsufficientAllowance   => Int32 2
  | CodeIsSender                => Int32 3
  | CodeNotWhitelisted          => Int32 -11
  | CodeNotImplementation       => Int32 -12
  | CodeNotOwner                => Int32 -13
  | CodeContractPaused          => Int32 -14
  end
  in
{ _exception : "Error"; code : result_code }


let get_val =
  fun (some_val: Option Uint128) =>
  match some_val with
  | Some val => val
  | None => zero
  end
  
contract FranSwap
(
    contract_owner: ByStr20,
    franc_token_address: ByStr20
)
(* Mutable fields *)
field owner_addr: ByStr20 = contract_owner
field pending_owner : Option ByStr20 = None {ByStr20}

field marginRate : Uint128 = Uint128 9950

field contractPaused : Bool = True

field franc_address : ByStr20 = franc_token_address
field token_to_franc_rate: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field franc_to_token_rate: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field token_balances: Map ByStr20 Uint128 = Emp ByStr20 Uint128


(* Procedures *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure isOwner()
  owner <- owner_addr;
  isOwner = builtin eq owner _sender;
  match isOwner with
    | True => (*Carry On*)
    | False =>
      err = CodeNotOwner;
      ThrowError err
  end
end

procedure isPaused()
  pause <- contractPaused;
  match pause with
    | True =>
      err = CodeContractPaused;
      ThrowError err
    | False =>(*Allow through*)
  end
end


transition swapTokenToFranc(token_address: ByStr20, amount: Uint128)
  isPaused;
  (*Check if token is whitelisted*)
  tokenWhitelisted <- token_to_franc_rate[token_address];
  match tokenWhitelisted with
    | Some rate =>
      msg = {_tag: "TransferFrom"; _recipient : token_address; _amount: zero; from: _sender; to: _this_address; amount: amount};
      msgs = one_msg msg;
      send msgs
    | None =>
      (*Token not whitelisted*)
      err = CodeNotWhitelisted;
      ThrowError err
  end
end

transition swapFrancToToken(token_address: ByStr20, amount: Uint128)
  isPaused;
  (*Check if token is whitelisted*)
  tokenWhitelisted <- franc_to_token_rate[token_address];
  match tokenWhitelisted with
    | Some rate =>
      franc_addr <- franc_address;
      msg = {_tag: "TransferFrom"; _recipient : franc_addr; _amount: zero; from: _sender; to: _this_address; amount: amount};
      msgs = one_msg msg;
      send msgs;
      
      token_amount = builtin mul amount rate;
      padAmount = builtin mul token_amount tenthousand;
      (*Initial of 9950 would equate to 99.50% back to user*)
      returnUserRate <- marginRate;
      margin_percent = builtin sub tenthousand returnUserRate;
      margin_amount = builtin mul token_amount margin_percent;
      padded_token_to_recipient = builtin sub padAmount margin_amount;
      token_to_recipient = builtin div padded_token_to_recipient tenthousand;
      
      (*deduct token held balances*)
      tok_bal <- token_balances[token_address];
      bal = get_val tok_bal;
      newBal = builtin sub bal amount;
      token_balances[token_address] := newBal;
      
      franc_addr <- franc_address;
      msg = {_tag : "Transfer"; _recipient: franc_addr; _amount: zero;
              to: _sender; amount: token_to_recipient};
      msgs = one_msg msg;
      send msgs
      
    | None =>
      (*Token not whitelisted*)
      err = CodeNotWhitelisted;
      ThrowError err
  end
end

transition setTokenToFrancRate(token_address: ByStr20, rate: Uint128)
end

transition setFrancToTokenRate(token_address: ByStr20, rate: Uint128)
end

transition whitelistTokenAddress(token_address: ByStr20, franc_token_rate: Uint128, token_franc_rate: Uint128)
end

transition removeWhitelistTokenAddress(token_address: ByStr20)
end

transition changeMargin(margin: Uint128)

end

transition changeFrancAddr(address: ByStr20)
end

transition pauseContract()
end

transition unpauseContract()
end



(*Transitions is needed should a TransferFrom be Used to send funds to this contract, without this transition the contract will reject any zrc-2 tokens*)
transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  isPaused;
  (*Check if token is whitelisted*)
  tokenWhitelisted <- token_to_franc_rate[_sender];
  match tokenWhitelisted with
    | Some rate =>
      (*This would require franc to be at least 5 decimal places*)
      franc_amount = builtin div amount rate;
      padAmount = builtin mul franc_amount tenthousand;
      (*Initial of 9950 would equate to 99.50% back to user*)
      returnUserRate <- marginRate;
      margin_percent = builtin sub tenthousand returnUserRate;
      margin_amount = builtin mul franc_amount margin_percent;
      padded_franc_to_recipient = builtin sub padAmount margin_amount;
      franc_to_recipient = builtin div padded_franc_to_recipient tenthousand;
      
      (*Add token held balances*)
      tok_bal <- token_balances[_sender];
      bal = get_val tok_bal;
      newBal = builtin add bal amount;
      token_balances[_sender] := newBal;
      
      franc_addr <- franc_address;
      msg = {_tag : "Transfer"; _recipient: franc_addr; _amount: zero;
              to: sender; amount: franc_to_recipient};
      msgs = one_msg msg;
      send msgs
    | None =>
      (*Token not whitelisted*)
      err = CodeNotWhitelisted;
      ThrowError err
  end
end

(*Transitions is needed should a Transfer be Used to send funds to this contract, without this transition the contract will reject any zrc-2 tokens*)
(*Sent into this contract via the Transfer Transition, similar to how u send your tokens from one wallet to another*)
transition RecipientAcceptTransfer(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)

end


(*When sending out ZRC-2 tokens via the transfer transition on the token smart contract, this is needed by the sender to determine the status of transaction whether the transaction is successful*)
(*Should it fail, the transaction is reverted*)
transition TransferSuccessCallBack(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

(*When sending out ZRC-2 tokens via the transferFrom transition on the token smart contract, this is needed by the sender to determine the status of transaction whether the transaction is successful*)
(*Should it fail, the transaction is reverted*)
transition TransferFromSuccessCallBack (
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end









